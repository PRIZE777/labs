Compiler
========

A Symfony project created on May 1, 2017, 3:44 pm.

Source: src/CompilerBundle/

<h2>Общее писание:</h2>

<ul>
	<li>Единственный тип данных — int;</li>
	<li>Все переменные — глобальные. Всего есть 26 переменных (a-z);</li>
	<li>Из математических операций поддерживаются только "+" и "-";</li>
	<li>Единственный оператор сравнения — это "<";</li>
	<li>Из конструкций языка — условные операторы if, if/else, while, do/while.</li>
</ul>

Программа — это один оператор (statement). Операторы бывают условными (if..else...), циклическими (while...) и просто операторами (напр., «a=2+3»). Условные и циклические содержат в себе выражение-условие и тело (в виде оператора). Обычные операторы заканчиваются точкой с запятой. Можно группировать операторы в фигурных скобках, тогда получим составной оператор. Выражения — это либо сумма, либо присваивание переменной значения. Сумма — это последовательность сложений-вычитаний термов. Терм — это число, переменная или выражение в скобках. Переменные — это символы от a до z. Числа — это набор цифр от 0 до 9.


<h2>Лексер:</h2>

Лексический анализатор распознает следующие токены:

<ul>
	<li>Числа;</li>
	<li>Идентификаторы-переменные;</li>
	<li>Ключевые слова: if, else, while, do;</li>
	<li>Символы +, -, <, =, ;, {, }, (, ).</li>
</ul>

Анализатор игнорирует пробелы, проверяет, является ли текущий символ специальным символом языка, если нет — проверяет, является ли он числом или идентификатором. Т.е. встретив цифру 1, анализатор продолжит вычитывать символы, пока не встретит не-числовой символ. Аналогично проверяются идентификаторы (там вместо чисел буквы). Значение переменных хранится в виде ASKII кода.

<h2>Парсер:</h2>

Парсер, используя токены, полученные от лексического анализатора, формирует дерево, в котором иерархия и связи отображают структуру кода. Например:

![alt text](https://pp.userapi.com/c837539/v837539581/4bbb1/StG807eqz44.jpg)

Дерево, которое строится парсером, состоит из узлов. У узла есть тип (IF, LESS, SET, VAR...), значение (если это число или переменная) и несколько дочерних узлов-операндов (в коде — op1, op2, op3). Для if в них хранятся условие и ветки then/else, для циклов — условие и тело цикла. 

Программа дает возможность посмотреть структуру дерева.

<h2>Компилятор:</h2>

Работа компилятора заключается в том, чтобы рекурсивно обойти полученное в парсере дерево и для каждого узла сгенерировать соответствующий код. Обход каждого узла добавляет новый байт (команду или аргумент) в программу, представляющую из себя список байт. 

Программа выводит все значения переменных, если они не являются нулевыми. Переменные значения которых оказались нулевыми в рамках вычислений, не выводятся. Так же программа позволяет, как и в случае с парсером, посмотреть массив программного кода (список байт) в адаптированном виде.

<h2>Машинный код:</h2>

Компиляция происходит в байт-код виртуальной машины. Виртуальная машина является стековой. Ее возможные инструкции:

<ul>
<li>FETCH x - положить на стек значение переменной x;</li>
<li>STORE x - сохранить в переменной x значение с вершины стека;</li>
<li>PUSH  n - положить число n на вершину стека;</li>
<li>POP - удалить число с вершины стека;</li>
<li>ADD - сложить два числа на вершине стека;</li>
<li>SUB - вычесть два числа на вершине стека;</li>
<li>LT - сравнить два числа с вершины стека (a < b). Результат - 0 или 1;</li>
<li>JZ a - если на вершине стека 0 - перейти к адресу a;</li>
<li>JNZ a - если на вершине стека не 0 - перейти к адресу a;</li>
<li>JMP a - перейти к адресу a;</li>
<li>HALT - завершить работу.</li>
</ul>

<h2>Проверка компилятора (примеры):</h2>

<ul>
<li>i =	3;</li>
<li>{ a=3; b=5; }</li>
<li>{ a = 1; b = 2; c = a + b; }</li>
<li>{ a = 5; b = 2; c = a - b; }</li>
<li>{ a = 5; b = 2; c = b < a; }</li>
<li>{ a = 5; if (a < 10) a = 33; }</li>
<li>{ a = 5; if (10 < a) a = 33; else { a = 1; b = 2; } }</li>
<li>{ a = 10; do { a = a - 2;}  while (3 < a); }</li>
<li>{ a = 1; b = 5; while (a < b) { a = a + 3; }}</li>
</ul>
